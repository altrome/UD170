1
00:00:00,740 --> 00:00:02,969
You may think it's pretty inefficient that we have to

2
00:00:02,969 --> 00:00:05,760
type a URL into the browser every time we want to grab

3
00:00:05,760 --> 00:00:09,450
some data from last.fm's API. There has to be a

4
00:00:09,450 --> 00:00:12,980
more efficient way to do this and you're right. We can

5
00:00:12,980 --> 00:00:15,740
write a simple Python program that uses the JSON and

6
00:00:15,740 --> 00:00:18,740
request libraries to do exactly what we did manually a few

7
00:00:18,740 --> 00:00:22,160
moments ago. If we run this program right here, let's think

8
00:00:22,160 --> 00:00:25,880
of what it returns. Look, the data that this Python program

9
00:00:25,880 --> 00:00:28,200
returned is exactly the same based on data that

10
00:00:28,200 --> 00:00:30,742
you saw in the browser a second ago. This

11
00:00:30,742 --> 00:00:34,060
program was less than 10 lines. First we specify

12
00:00:34,060 --> 00:00:38,706
a URL, then we simply say request that get,

13
00:00:38,706 --> 00:00:42,980
that URL and call.text, in order to get the

14
00:00:42,980 --> 00:00:46,330
text. We assign that value to data. We print

15
00:00:46,330 --> 00:00:48,830
type of data which we saw was Unicode, and

16
00:00:48,830 --> 00:00:52,190
we print data itself, which was the JSON object.

17
00:00:52,190 --> 00:00:53,620
But if we go back and look at the JSON

18
00:00:53,620 --> 00:00:56,530
object itself, we see that it's in this funky string format

19
00:00:56,530 --> 00:00:58,390
that makes it very hard for us to parse out

20
00:00:58,390 --> 00:01:02,180
the interesting information. We could write a Regex to parse out

21
00:01:02,180 --> 00:01:04,670
what we want, but that can get pretty painful really

22
00:01:04,670 --> 00:01:08,660
quickly. The JSON library will make interacting with JSON data as

23
00:01:08,660 --> 00:01:12,090
easy as 1, 2, 3. Let me show you how.

24
00:01:12,090 --> 00:01:17,370
We've modified our script ever so slightly. After initially assigning data,

25
00:01:17,370 --> 00:01:20,374
we reassign it. We say data equals json.loads

26
00:01:20,374 --> 00:01:25,920
data. What json.loads does is it interprets a string

27
00:01:25,920 --> 00:01:28,960
and assumes that it's a JSON object. By doing

28
00:01:28,960 --> 00:01:31,380
so, we convert the JSON data into a Python

29
00:01:31,380 --> 00:01:34,310
dictionary. We'll see that when we print type

30
00:01:34,310 --> 00:01:36,760
data. Once we convert the data into a nicely

31
00:01:36,760 --> 00:01:39,580
structured dictionary, we can get the interesting bits out

32
00:01:39,580 --> 00:01:42,210
as if we're simply accessing a dictionary. For example,

33
00:01:42,210 --> 00:01:45,670
typing data artist. Let's see what this script

34
00:01:45,670 --> 00:01:49,260
produces now. As we can see, what we return

35
00:01:49,260 --> 00:01:51,180
here is that the type of the object is

36
00:01:51,180 --> 00:01:54,520
a dictionary and then we have a Python dictionary.
